diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,12 @@
+node_modules
+dist
+.env
+.DS_Store
+npm-debug.log*
+yarn-error.log*
+pnpm-debug.log*
+/.idea
+/.vscode
+/data
+*.sqlite
+*.db
diff --git a/.env.example b/.env.example
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/.env.example
@@ -0,0 +1,20 @@
+# === Required ===
+TELEGRAM_BOT_TOKEN=123456:ABC-your-bot-token
+FORWARD_TARGET_ID=-1001234567890           # 目标频道/群/用户ID（频道常为 -100 开头）
+ADMIN_IDS=111111111,222222222              # 逗号分隔管理员ID（需先私聊启动过机器人）
+
+# === Optional ===
+WEBHOOK_URL=https://your-app.onrender.com  # 不填则使用轮询（长轮询）
+WELCOME_TEXT=👋 欢迎！点击“开始”或“菜单”
+ATTACH_BUTTONS_TO_TARGET_META=1            # 审核通过后在目标频道追加带按钮的说明
+PER_USER_COOLDOWN_MS=3000
+GLOBAL_MIN_TIME_MS=60
+ALLOWLIST_MODE=0                           # 1=开启白名单模式
+
+# === Persistence ===
+PERSIST_BACKEND=redis                      # redis | sqlite
+REDIS_URL=redis://default:password@host:6379/0
+SQLITE_PATH=/data/bot.db                   # 使用持久化磁盘挂载到 /data
+REVIEW_TARGET_ID=-1009999999999            # （可选）审核频道/群/私人ID；留空则逐个发给 ADMIN_IDS
+ADTPL_DEFAULT_THRESHOLD=0.6                # 模板默认阈值（0~1）
+
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/README.md
@@ -0,0 +1,86 @@
+# Telegram Moderated Forward Bot (Redis/SQLite)
+
+一个可在 Render 部署的 Telegram 机器人：
+- 审核转发（管理员通过后转发到目标频道）
+- 审核频道（REVIEW_TARGET_ID）统一收审
+- 引流按钮（管理员在 bot 内编辑）
+- 欢迎语、菜单（回复键盘 + inline 键盘）
+- 模糊广告模板检测（3-gram Jaccard）
+- 速率限制（全局 + 每用户冷却）
+- **持久化：Redis 或 SQLite（二选一）**
+
+## 环境变量
+见 `.env.example`。
+
+- Redis：设置 `PERSIST_BACKEND=redis` 且提供 `REDIS_URL`
+- SQLite：设置 `PERSIST_BACKEND=sqlite` 且提供 `SQLITE_PATH`（挂载持久化磁盘到该路径所在目录）
+
+## Render 配置
+- Build: `npm ci && npm run build`
+- Start: `npm run start`
+- Health Check Path: `/healthz`
+
+## 管理命令（在 Telegram 内）
+- `/config` 查看配置
+- `/set_review_target <id>` 设置审核频道/群/用户 ID（留空关闭→逐个发管理员）
+- `/set_target <id>` 设置最终转发目标 ID
+- `/set_welcome <文本>` 设置欢迎语
+- `/set_attach_buttons 1|0` 审核通过后的说明是否附带引流按钮
+- `/set_rate <per_user_ms> <global_min_ms>` 速率参数（建议重启后更稳）
+- `/toggle_allowlist 1|0` 白名单模式开关
+- `/admins_list` `/admins_add <id>` `/admins_del <id>` 管理管理员列表
+
+### 引流按钮
+- `/btn_list`
+- `/btn_add "显示文字" https://链接 顺序`
+- `/btn_set 序号 "显示文字" https://链接 顺序`
+- `/btn_del 序号`
+
+### 广告模板
+- `/adtpl_list`
+- `/adtpl_add "名称" "模板内容" 0.6`
+- `/adtpl_set 序号 "名称" "模板内容" 0.7`
+- `/adtpl_del 序号`
+- `/adtpl_test "任意文本"`
+
+## 审核流程
+非管理员消息 → 入待审队列 → 发送“原消息 + 审核按钮”到 `REVIEW_TARGET_ID`（若设置）或逐个管理员 → 通过/拒绝/封禁。通过后将原消息转发到 `FORWARD_TARGET_ID`。
+
+## 权限
+只有管理员（`ADMIN_IDS` 初始 + 后续通过命令维护）能执行配置与审核按钮操作。
+
+## 注意
+- 目标为频道时必须将机器人设为管理员
+- 若要接收群普通消息，BotFather `/setprivacy` 关闭隐私模式
+- 如果使用 SQLite，务必在 Render 上给该 Web 服务挂载 **Persistent Disk**，并将 `SQLITE_PATH` 指向磁盘目录下的 db 文件（例如 `/data/bot.db`）。
+
diff --git a/package.json b/package.json
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/package.json
@@ -0,0 +1,38 @@
+{
+  "name": "tg-mod-forward-bot",
+  "version": "1.0.0",
+  "private": true,
+  "description": "Telegram moderated forward bot with Redis/SQLite persistence for Render.",
+  "engines": { "node": "20.x" },
+  "main": "dist/index.js",
+  "scripts": {
+    "build": "rimraf dist && tsc -p tsconfig.json",
+    "start": "node dist/index.js"
+  },
+  "dependencies": {
+    "telegraf": "^4.16.3",
+    "express": "^4.19.2",
+    "bottleneck": "^2.19.5",
+    "dotenv": "^16.4.5",
+    "ioredis": "^5.4.1",
+    "better-sqlite3": "^9.5.0"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3",
+    "rimraf": "^6.0.1",
+    "@types/node": "^20.14.10",
+    "@types/express": "^4.17.21"
+  }
+}
diff --git a/tsconfig.json b/tsconfig.json
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/tsconfig.json
@@ -0,0 +1,21 @@
+{
+  "compilerOptions": {
+    "target": "ES2020",
+    "module": "CommonJS",
+    "moduleResolution": "node",
+    "outDir": "dist",
+    "rootDir": "src",
+    "esModuleInterop": true,
+    "resolveJsonModule": true,
+    "skipLibCheck": true,
+    "forceConsistentCasingInFileNames": true,
+    "strict": true
+  },
+  "include": ["src"]
+}
diff --git a/src/types.ts b/src/types.ts
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/src/types.ts
@@ -0,0 +1,24 @@
+export type TrafficBtn = { text: string; url: string; order: number };
+export type AdTemplate = { name: string; content: string; threshold: number };
+export type Suspected = { template: string; score: number };
+
+export type Req = {
+  id: string;
+  sourceChatId: number | string;
+  messageId: number;
+  fromId: number;
+  fromName: string;
+  createdAt: number;
+  suspected?: Suspected;
+};
+
+export type Config = {
+  forwardTargetId: string;     // 目标转发ID
+  reviewTargetId?: string;     // 审核频道/群/私人
+  welcomeText: string;
+  attachButtonsToTargetMeta: boolean;
+  adminIds: string[];
+  allowlistMode: boolean;
+  adtplDefaultThreshold: number;
+};
diff --git a/src/store.ts b/src/store.ts
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/src/store.ts
@@ -0,0 +1,258 @@
+import type { Config, TrafficBtn, AdTemplate, Req } from "./types";
+import Redis from "ioredis";
+import Database from "better-sqlite3";
+
+export interface Store {
+  init(): Promise<void>;
+  // config
+  getConfig(): Promise<Config>;
+  setConfig(partial: Partial<Config>): Promise<void>;
+  // buttons
+  listButtons(): Promise<TrafficBtn[]>;
+  setButtons(btns: TrafficBtn[]): Promise<void>;
+  // templates
+  listTemplates(): Promise<AdTemplate[]>;
+  setTemplates(templates: AdTemplate[]): Promise<void>;
+  // allow/block lists
+  listAllow(): Promise<number[]>;
+  addAllow(id: number): Promise<void>;
+  removeAllow(id: number): Promise<void>;
+  listBlock(): Promise<number[]>;
+  addBlock(id: number): Promise<void>;
+  removeBlock(id: number): Promise<void>;
+  // pending queue
+  getPending(id: string): Promise<Req | null>;
+  setPending(req: Req): Promise<void>;
+  delPending(id: string): Promise<void>;
+}
+
+function defaultConfig(env: NodeJS.ProcessEnv): Config {
+  return {
+    forwardTargetId: env.FORWARD_TARGET_ID || "",
+    reviewTargetId: env.REVIEW_TARGET_ID || "",
+    welcomeText: env.WELCOME_TEXT || "👋 欢迎！点击左下角“开始”或使用菜单按钮",
+    attachButtonsToTargetMeta: (env.ATTACH_BUTTONS_TO_TARGET_META || "1") === "1",
+    adminIds: (env.ADMIN_IDS || "").split(",").map(s => s.trim()).filter(Boolean),
+    allowlistMode: (env.ALLOWLIST_MODE || "0") === "1",
+    adtplDefaultThreshold: Math.min(1, Math.max(0, Number(env.ADTPL_DEFAULT_THRESHOLD ?? 0.6)))
+  };
+}
+
+/* ---------------- Redis Store ---------------- */
+export class RedisStore implements Store {
+  private r: Redis;
+  private prefix: string;
+  constructor(url: string, prefix = "tgmod") {
+    this.r = new Redis(url);
+    this.prefix = prefix;
+  }
+  async init() {
+    // nothing
+  }
+  private k(key: string) { return `${this.prefix}:${key}`; }
+
+  async getConfig(): Promise<Config> {
+    const raw = await this.r.get(this.k("config"));
+    if (raw) return JSON.parse(raw);
+    const cfg = defaultConfig(process.env);
+    await this.setConfig(cfg);
+    return cfg;
+  }
+  async setConfig(partial: Partial<Config> | Config) {
+    const current = await this.getConfig();
+    const next = { ...current, ...partial };
+    await this.r.set(this.k("config"), JSON.stringify(next));
+  }
+
+  async listButtons(): Promise<TrafficBtn[]> {
+    const raw = await this.r.get(this.k("buttons"));
+    return raw ? JSON.parse(raw) : [];
+  }
+  async setButtons(btns: TrafficBtn[]) {
+    await this.r.set(this.k("buttons"), JSON.stringify(btns));
+  }
+
+  async listTemplates(): Promise<AdTemplate[]> {
+    const raw = await this.r.get(this.k("templates"));
+    return raw ? JSON.parse(raw) : [];
+  }
+  async setTemplates(tpls: AdTemplate[]) {
+    await this.r.set(this.k("templates"), JSON.stringify(tpls));
+  }
+
+  async listAllow(): Promise<number[]> {
+    const members = await this.r.smembers(this.k("allowlist"));
+    return members.map(Number);
+  }
+    async addAllow(id: number) { await this.r.sadd(this.k("allowlist"), id.toString()); }
+  async removeAllow(id: number) { await this.r.srem(this.k("allowlist"), id.toString()); }
+
+  async listBlock(): Promise<number[]> {
+    const members = await this.r.smembers(this.k("blocklist"));
+    return members.map(Number);
+  }
+  async addBlock(id: number) { await this.r.sadd(this.k("blocklist"), id.toString()); }
+  async removeBlock(id: number) { await this.r.srem(this.k("blocklist"), id.toString()); }
+
+  async getPending(id: string): Promise<Req | null> {
+    const raw = await this.r.hget(this.k("pending"), id);
+    return raw ? JSON.parse(raw) : null;
+  }
+  async setPending(req: Req) {
+    await this.r.hset(this.k("pending"), { [req.id]: JSON.stringify(req) });
+  }
+  async delPending(id: string) {
+    await this.r.hdel(this.k("pending"), id);
+  }
+}
+
+/* ---------------- SQLite Store ---------------- */
+export class SqliteStore implements Store {
+  private db: Database.Database;
+  constructor(path: string) {
+    this.db = new Database(path);
+  }
+  async init() {
+    this.db.exec(`
+      CREATE TABLE IF NOT EXISTS config (
+        key TEXT PRIMARY KEY,
+        value TEXT NOT NULL
+      );
+      CREATE TABLE IF NOT EXISTS buttons (
+        id INTEGER PRIMARY KEY AUTOINCREMENT,
+        text TEXT NOT NULL,
+        url TEXT NOT NULL,
+        ord INTEGER NOT NULL
+      );
+      CREATE TABLE IF NOT EXISTS templates (
+        id INTEGER PRIMARY KEY AUTOINCREMENT,
+        name TEXT NOT NULL,
+        content TEXT NOT NULL,
+        threshold REAL NOT NULL
+      );
+      CREATE TABLE IF NOT EXISTS allowlist (user_id INTEGER PRIMARY KEY);
+      CREATE TABLE IF NOT EXISTS blocklist (user_id INTEGER PRIMARY KEY);
+      CREATE TABLE IF NOT EXISTS pending (
+        id TEXT PRIMARY KEY,
+        sourceChatId TEXT NOT NULL,
+        messageId INTEGER NOT NULL,
+        fromId INTEGER NOT NULL,
+        fromName TEXT NOT NULL,
+        createdAt INTEGER NOT NULL,
+        suspected_template TEXT,
+        suspected_score REAL
+      );
+    `);
+    // seed config if empty
+    const row = this.db.prepare("SELECT value FROM config WHERE key='config'").get();
+    if (!row) {
+      const cfg = defaultConfig(process.env);
+      this.db.prepare("INSERT INTO config (key, value) VALUES ('config', ?)").run(JSON.stringify(cfg));
+    }
+  }
+
+  async getConfig(): Promise<Config> {
+    const row = this.db.prepare("SELECT value FROM config WHERE key='config'").get();
+    if (row?.value) return JSON.parse(row.value);
+    const cfg = defaultConfig(process.env);
+    await this.setConfig(cfg);
+    return cfg;
+  }
+  async setConfig(partial: Partial<Config> | Config) {
+    const current = await this.getConfig();
+    const next = { ...current, ...partial };
+    this.db.prepare("INSERT INTO config(key, value) VALUES ('config', ?) ON CONFLICT(key) DO UPDATE SET value=excluded.value").run(JSON.stringify(next));
+  }
+
+  async listButtons(): Promise<TrafficBtn[]> {
+    const rows = this.db.prepare("SELECT text, url, ord AS 'order' FROM buttons ORDER BY ord ASC").all();
+    return rows as TrafficBtn[];
+  }
+  async setButtons(btns: TrafficBtn[]) {
+    const trx = this.db.transaction((arr: TrafficBtn[]) => {
+      this.db.prepare("DELETE FROM buttons").run();
+      const stmt = this.db.prepare("INSERT INTO buttons(text, url, ord) VALUES (?, ?, ?)");
+      for (const b of arr) stmt.run(b.text, b.url, b.order);
+    });
+    trx(btns);
+  }
+
+  async listTemplates(): Promise<AdTemplate[]> {
+    const rows = this.db.prepare("SELECT name, content, threshold FROM templates ORDER BY id ASC").all();
+    return rows as AdTemplate[];
+  }
+  async setTemplates(tpls: AdTemplate[]) {
+    const trx = this.db.transaction((arr: AdTemplate[]) => {
+      this.db.prepare("DELETE FROM templates").run();
+      const stmt = this.db.prepare("INSERT INTO templates(name, content, threshold) VALUES (?, ?, ?)");
+      for (const t of arr) stmt.run(t.name, t.content, t.threshold);
+    });
+    trx(tpls);
+  }
+
+  async listAllow(): Promise<number[]> {
+    return this.db.prepare("SELECT user_id FROM allowlist").all().map((r: any) => r.user_id);
+  }
+  async addAllow(id: number) { this.db.prepare("INSERT OR IGNORE INTO allowlist(user_id) VALUES (?)").run(id); }
+  async removeAllow(id: number) { this.db.prepare("DELETE FROM allowlist WHERE user_id=?").run(id); }
+
+  async listBlock(): Promise<number[]> {
+    return this.db.prepare("SELECT user_id FROM blocklist").all().map((r: any) => r.user_id);
+  }
+  async addBlock(id: number) { this.db.prepare("INSERT OR IGNORE INTO blocklist(user_id) VALUES (?)").run(id); }
+  async removeBlock(id: number) { this.db.prepare("DELETE FROM blocklist WHERE user_id=?").run(id); }
+
+  async getPending(id: string): Promise<Req | null> {
+    const r = this.db.prepare("SELECT * FROM pending WHERE id=?").get(id);
+    if (!r) return null;
+    const req: Req = {
+      id: r.id,
+      sourceChatId: isNaN(Number(r.sourceChatId)) ? r.sourceChatId : Number(r.sourceChatId),
+      messageId: r.messageId,
+      fromId: r.fromId,
+      fromName: r.fromName,
+      createdAt: r.createdAt,
+      suspected: r.suspected_template ? { template: r.suspected_template, score: r.suspected_score } : undefined
+    };
+    return req;
+  }
+  async setPending(req: Req) {
+    this.db.prepare(`INSERT OR REPLACE INTO pending(id, sourceChatId, messageId, fromId, fromName, createdAt, suspected_template, suspected_score)
+      VALUES (?, ?, ?, ?, ?, ?, ?, ?)`)
+      .run(req.id, String(req.sourceChatId), req.messageId, req.fromId, req.fromName, req.createdAt, req.suspected?.template ?? null, req.suspected?.score ?? null);
+  }
+  async delPending(id: string) {
+    this.db.prepare("DELETE FROM pending WHERE id=?").run(id);
+  }
+}
+
+export function buildStore(): Store {
+  const backend = (process.env.PERSIST_BACKEND || "redis").toLowerCase();
+  if (backend === "sqlite") {
+    const path = process.env.SQLITE_PATH || "./data/bot.db";
+    return new SqliteStore(path);
+  }
+  const url = process.env.REDIS_URL || "redis://127.0.0.1:6379/0";
+  return new RedisStore(url);
+}
diff --git a/src/index.ts b/src/index.ts
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/src/index.ts
@@ -0,0 +1,694 @@
+import "dotenv/config";
+import express from "express";
+import Bottleneck from "bottleneck";
+import { Telegraf, Markup, Context } from "telegraf";
+import type { TrafficBtn, AdTemplate, Req, Config, Suspected } from "./types";
+import { buildStore, Store } from "./store";
+
+/** ====== Boot ====== */
+const TOKEN = process.env.TELEGRAM_BOT_TOKEN!;
+if (!TOKEN) throw new Error("缺少 TELEGRAM_BOT_TOKEN");
+const bot = new Telegraf(TOKEN);
+const app = express();
+app.use(express.json());
+
+// Health check
+app.get("/healthz", (_req, res) => res.status(200).send("ok"));
+
+// Limits
+const PER_USER_COOLDOWN_MS = Number(process.env.PER_USER_COOLDOWN_MS || 3000);
+const GLOBAL_MIN_TIME_MS = Number(process.env.GLOBAL_MIN_TIME_MS || 60);
+const limiter = new Bottleneck({ minTime: GLOBAL_MIN_TIME_MS, maxConcurrent: 1 });
+const safeCall = async <T,>(fn: () => Promise<T>): Promise<T | undefined> => {
+  try { return await limiter.schedule(fn); } catch (e) { console.error(e); return; }
+};
+
+/** ====== Store & Config ====== */
+const store: Store = buildStore();
+let cfg: Config;
+let buttons: TrafficBtn[] = [];
+let templates: AdTemplate[] = [];
+let allowlistSet = new Set<number>();
+let blocklistSet = new Set<number>();
+let allowlistMode = false;
+
+// Dedup & user cooldown (in-memory)
+const dedup = new Map<string, number>();
+const userCooldown = new Map<number, number>();
+
+function isAdmin(id?: number) { return !!id && cfg.adminIds.includes(String(id)); }
+function buildTrafficKeyboard() {
+  if (buttons.length === 0) return undefined;
+  const sorted = [...buttons].sort((a,b)=>a.order-b.order);
+  const rows: any[] = [];
+  for (let i=0; i<sorted.length; i+=2) rows.push(sorted.slice(i,i+2).map(b=>Markup.button.url(b.text,b.url)));
+  return Markup.inlineKeyboard(rows);
+}
+function buildReplyKeyboard() { return Markup.keyboard([["开始","菜单"]]).resize(true).oneTime(false); }
+
+function human(u?: { username?: string; first_name?: string; last_name?: string; id?: number }) {
+  if (!u) return "未知用户";
+  const name = [u.first_name, u.last_name].filter(Boolean).join(" ").trim();
+  return u.username ? `@${u.username}` : (name || `ID:${u.id}`);
+}
+function parseArgsQuoted(s: string): string[] {
+  const out: string[] = []; const re = /"([^"]+)"|'([^']+)'|(\\S+)/g; let m: RegExpExecArray | null;
+  while ((m = re.exec(s))) out.push(m[1] || m[2] || m[3]);
+  return out;
+}
+function isValidUrl(u: string) { return /^https?:\\/\\/\\S+/i.test(u); }
+
+// normalize & n-gram
+function toHalfWidth(str: string): string {
+  return str.replace(/[\\uFF01-\\uFF5E]/g, (ch) => String.fromCharCode(ch.charCodeAt(0) - 0xFEE0)).replace(/\\u3000/g, " ");
+}
+function normalizeText(s: string): string {
+  const lower = toHalfWidth(s).toLowerCase();
+  const stripped = lower.replace(/[^\\p{Letter}\\p{Number}\\u4e00-\\u9fa5]+/gu, "");
+  return stripped;
+}
+function ngrams(s: string, n: number): Set<string> {
+  const set = new Set<string>(); if (!s) return set;
+  const N = Math.max(1, Math.min(n, s.length));
+  for (let i=0;i<=s.length-N;i++) set.add(s.slice(i,i+N));
+  return set;
+}
+function jaccard(a: Set<string>, b: Set<string>): number {
+  if (a.size===0 && b.size===0) return 1; let inter=0;
+  for (const x of a) if (b.has(x)) inter++; const uni=a.size+b.size-inter;
+  return uni===0?0:inter/uni;
+}
+function detectAdTemplate(text: string): { matched: boolean; name?: string; score?: number } {
+  const norm = normalizeText(text); if (!norm) return { matched:false };
+  const a = ngrams(norm, norm.length >=3 ? 3 : 2);
+  let best = { name: "", score: 0, thr: cfg.adtplDefaultThreshold };
+  for (const tpl of templates) {
+    const b = ngrams(normalizeText(tpl.content), tpl.content.length>=3?3:2);
+    const score = jaccard(a,b);
+    const thr = Math.max(0, Math.min(1, tpl.threshold ?? cfg.adtplDefaultThreshold));
+    if (score>=thr && score>best.score) best = { name: tpl.name, score, thr };
+  }
+  if (best.score >= (best.thr || cfg.adtplDefaultThreshold)) return { matched:true, name:best.name, score:Number(best.score.toFixed(3)) };
+  return { matched:false };
+}
+
+function extractMessageText(msg: any): string {
+  return (msg?.text ?? msg?.caption ?? "").toString();
+}
+
+async function loadAll() {
+  await store.init();
+  cfg = await store.getConfig();
+  buttons = await store.listButtons();
+  templates = await store.listTemplates();
+  allowlistSet = new Set(await store.listAllow());
+  blocklistSet = new Set(await store.listBlock());
+  allowlistMode = cfg.allowlistMode;
+  if (!cfg.forwardTargetId) throw new Error("配置缺少 forwardTargetId（FORWARD_TARGET_ID）");
+}
+
+/** ====== Welcome/Menu ====== */
+async function showWelcome(ctx: Context) {
+  await safeCall(() => (ctx as any).reply(cfg.welcomeText, buildReplyKeyboard()));
+  const kb = buildTrafficKeyboard();
+  if (kb) await safeCall(() => (ctx as any).reply("👇 精选导航", kb));
+}
+bot.start((ctx)=>showWelcome(ctx));
+bot.hears(/^开始$/i, (ctx)=>showWelcome(ctx));
+bot.hears(/^菜单$/i, (ctx)=>{
+  const kb = buildTrafficKeyboard();
+  if (kb) return void safeCall(()=>ctx.reply("👇 菜单 / 导航", kb));
+  return void safeCall(()=>ctx.reply("暂无菜单按钮，管理员可用「添加按钮」命令新增。"));
+});
+
+/** ====== Main message handler (moderation flow) ====== */
+bot.on("message", async (ctx) => {
+  const fromId = ctx.from?.id; const chatId = ctx.chat?.id; const mid = (ctx.message as any)?.message_id;
+  if (!fromId || !chatId || !mid) return;
+
+  // Block/Allow
+  if (blocklistSet.has(fromId)) return;
+  if (allowlistMode && !allowlistSet.has(fromId) && !isAdmin(fromId)) {
+    await safeCall(()=>ctx.reply("🚫 未在白名单，消息不予处理"));
+    return;
+  }
+  // dedup
+  const key = `${chatId}:${mid}`; const now = Date.now();
+  if ((dedup.get(key)||0) + 1000 > now) return;
+  dedup.set(key, now);
+  for (const [k, ts] of dedup) if (now - ts > 60_000) dedup.delete(k);
+  // cooldown
+  const lastTs = userCooldown.get(fromId) || 0;
+  if (!isAdmin(fromId) && now - lastTs < PER_USER_COOLDOWN_MS) {
+    await safeCall(()=>ctx.reply(`⏳ 你发太快了，请 ${Math.ceil((PER_USER_COOLDOWN_MS - (now - lastTs))/1000)}s 后重试`));
+    return;
+  }
+  userCooldown.set(fromId, now);
+
+  // Admin bypass
+  if (isAdmin(fromId)) {
+    await forwardToTarget(ctx, chatId, mid, fromId, fromId, undefined);
+    return;
+  }
+
+  // Detect template
+  const txt = extractMessageText(ctx.message);
+  const hit = detectAdTemplate(txt);
+
+  // Enqueue pending
+  const id = `${now}_${chatId}_${mid}`;
+  const req: Req = { id, sourceChatId: chatId, messageId: mid, fromId, fromName: human(ctx.from), createdAt: now,
+    suspected: hit.matched ? { template: hit.name!, score: hit.score! } : undefined
+  };
+  await store.setPending(req);
+  await safeCall(()=>ctx.reply(hit.matched ? `📝 已提交审核（⚠️ 疑似模板：${req.suspected!.template}，score=${req.suspected!.score}）` : "📝 已提交审核，请等待管理员处理"));
+
+  // Send to review target or admins
+  const reviewText = `🕵️ 审核请求 #${id}
+来自：${req.fromName} (ID:${fromId})
+来源 chatId: ${chatId}` + (hit.matched ? `
+⚠️ 疑似广告模板：${hit.name}（score=${hit.score}）` : "");
+
+  const kb = Markup.inlineKeyboard([
+    [Markup.button.callback("✅ 通过", `approve:${id}`), Markup.button.callback("❌ 拒绝", `reject:${id}`)],
+    [Markup.button.callback("⛔ 封禁此人", `ban:${fromId}`)]
+  ]);
+
+  if (cfg.reviewTargetId) {
+    await safeCall(()=>ctx.telegram.forwardMessage(Number(cfg.reviewTargetId), chatId, mid));
+    await safeCall(()=>ctx.telegram.sendMessage(Number(cfg.reviewTargetId), reviewText, kb));
+  } else {
+    for (const admin of cfg.adminIds) {
+      await safeCall(()=>ctx.telegram.forwardMessage(Number(admin), chatId, mid));
+      await safeCall(()=>ctx.telegram.sendMessage(Number(admin), reviewText, kb));
+    }
+  }
+});
+
+/** ====== Callback (approve/reject/ban) ====== */
+bot.on("callback_query", async (ctx) => {
+  const cb: any = ctx.callbackQuery; const data: string = cb.data || ""; const adminId = ctx.from?.id;
+  if (!isAdmin(adminId)) { await safeCall(()=>ctx.answerCbQuery("无权操作",{show_alert:true})); return; }
+
+  if (data.startsWith("approve:")) {
+    const id = data.split(":")[1];
+    const req = await store.getPending(id); if (!req) { await safeCall(()=>ctx.answerCbQuery("请求不存在或已处理")); return; }
+    await forwardToTarget(ctx, req.sourceChatId, req.messageId, req.fromId, adminId!, req.suspected);
+    await store.delPending(id);
+    await safeCall(()=>ctx.editMessageText(`✅ 已通过 #${id} 并转发`));
+    await safeCall(()=>ctx.answerCbQuery("已通过"));
+  } else if (data.startsWith("reject:")) {
+    const id = data.split(":")[1];
+    const req = await store.getPending(id);
+    if (!req) { await safeCall(()=>ctx.answerCbQuery("请求不存在或已处理")); return; }
+    await store.delPending(id);
+    await safeCall(()=>ctx.editMessageText(`❌ 已拒绝 #${id}`));
+    await safeCall(()=>ctx.answerCbQuery("已拒绝"));
+  } else if (data.startsWith("ban:")) {
+    const uid = Number(data.split(":")[1]);
+    blocklistSet.add(uid); await store.addBlock(uid);
+    await safeCall(()=>ctx.editMessageText(`⛔ 已封禁用户 ${uid}`));
+    await safeCall(()=>ctx.answerCbQuery("已封禁"));
+  }
+});
+
+/** ====== Admin: config & buttons & templates ====== */
+function requireAdmin(ctx: any): boolean {
+  if (!isAdmin(ctx.from?.id)) { return false; }
+  return true;
+}
+// /config —— 查看当前配置
+bot.command("config", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const text = `⚙️ 配置
+forwardTargetId: ${cfg.forwardTargetId}
+reviewTargetId: ${cfg.reviewTargetId || "(未设置，改为逐个发管理员)"}
+admins: ${cfg.adminIds.join(",")}
+welcomeText: ${cfg.welcomeText}
+attachButtonsToTargetMeta: ${cfg.attachButtonsToTargetMeta}
+allowlistMode: ${cfg.allowlistMode}
+adtplDefaultThreshold: ${cfg.adtplDefaultThreshold}
+按钮数: ${buttons.length}，模板数: ${templates.length}`;
+  await safeCall(()=>ctx.reply(text));
+});
+
+bot.command("set_review_target", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const id = (ctx.message as any).text.replace(/^\\/set_review_target\\s*/i,"").trim();
+  cfg.reviewTargetId = id || "";
+  await store.setConfig({ reviewTargetId: cfg.reviewTargetId });
+  await safeCall(()=>ctx.reply(`✅ 审核频道已设置为：${cfg.reviewTargetId || "(关闭，逐个发管理员)"}`));
+});
+
+bot.command("set_target", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const id = (ctx.message as any).text.replace(/^\\/set_target\\s*/i,"").trim();
+  if (!id) return void safeCall(()=>ctx.reply("用法：/set_target <ID>"));
+  cfg.forwardTargetId = id;
+  await store.setConfig({ forwardTargetId: id });
+  await safeCall(()=>ctx.reply(`✅ 转发目标已更新：${id}`));
+});
+
+bot.command("set_welcome", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const text = (ctx.message as any).text.replace(/^\\/set_welcome\\s*/i,"").trim();
+  if (!text) return void safeCall(()=>ctx.reply("用法：/set_welcome 欢迎语文本"));
+  cfg.welcomeText = text;
+  await store.setConfig({ welcomeText: text });
+  await safeCall(()=>ctx.reply("✅ 欢迎语已更新")); await showWelcome(ctx);
+});
+
+bot.command("set_attach_buttons", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const v = (ctx.message as any).text.replace(/^\\/set_attach_buttons\\s*/i,"").trim();
+  if (!/^([01]|true|false)$/i.test(v)) return void safeCall(()=>ctx.reply("用法：/set_attach_buttons 1|0"));
+  const flag = v === "1" || /^true$/i.test(v);
+  cfg.attachButtonsToTargetMeta = flag;
+  await store.setConfig({ attachButtonsToTargetMeta: flag });
+  await safeCall(()=>ctx.reply(`✅ 目标说明附带按钮：${flag?"开启":"关闭"}`));
+});
+
+bot.command("set_rate", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const parts = (ctx.message as any).text.split(/\\s+/).slice(1);
+  if (parts.length<2) return void safeCall(()=>ctx.reply("用法：/set_rate <per_user_ms> <global_min_ms>"));
+  const a = Number(parts[0]), b = Number(parts[1]);
+  if (Number.isNaN(a)||Number.isNaN(b)) return void safeCall(()=>ctx.reply("❌ 参数必须为数字毫秒"));
+  process.env.PER_USER_COOLDOWN_MS = String(a);
+  process.env.GLOBAL_MIN_TIME_MS = String(b);
+  await safeCall(()=>ctx.reply(`✅ 已设置：每人冷却 ${a} ms，全局最小间隔 ${b} ms\\n（重启后生效更稳）`));
+});
+
+bot.command("toggle_allowlist", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const v = (ctx.message as any).text.split(/\\s+/)[1];
+  if (!/^([01]|true|false)$/i.test(v)) return void safeCall(()=>ctx.reply("用法：/toggle_allowlist 1|0"));
+  const flag = v==="1" || /^true$/i.test(v);
+  allowlistMode = flag; cfg.allowlistMode = flag;
+  await store.setConfig({ allowlistMode: flag });
+  await safeCall(()=>ctx.reply(`✅ 白名单模式：${flag?"开启":"关闭"}`));
+});
+
+// Admins
+bot.command("admins_list", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  await safeCall(()=>ctx.reply("当前管理员：\\n" + cfg.adminIds.join("\\n")));
+});
+bot.command("admins_add", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const id = (ctx.message as any).text.split(/\\s+/)[1];
+  if (!id) return void safeCall(()=>ctx.reply("用法：/admins_add <userId>"));
+  if (!cfg.adminIds.includes(id)) cfg.adminIds.push(id);
+  await store.setConfig({ adminIds: cfg.adminIds });
+  await safeCall(()=>ctx.reply(`✅ 已添加管理员：${id}`));
+});
+bot.command("admins_del", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const id = (ctx.message as any).text.split(/\\s+/)[1];
+  if (!id) return void safeCall(()=>ctx.reply("用法：/admins_del <userId>"));
+  cfg.adminIds = cfg.adminIds.filter(x=>x!==id);
+  await store.setConfig({ adminIds: cfg.adminIds });
+  await safeCall(()=>ctx.reply(`✅ 已移除管理员：${id}`));
+});
+
+// Buttons
+bot.command("btn_list", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  if (buttons.length===0) return void safeCall(()=>ctx.reply("（空）没有任何按钮"));
+  const sorted = [...buttons].sort((a,b)=>a.order-b.order);
+  const lines = sorted.map((b,i)=>`${i+1}. [${b.text}] ${b.url} （顺序：${b.order}）`);
+  await safeCall(()=>ctx.reply("当前按钮：\\n"+lines.join("\\n")));
+  const kb = buildTrafficKeyboard(); if (kb) await safeCall(()=>ctx.reply("预览：", kb));
+});
+bot.command("btn_add", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const raw = (ctx.message as any).text.replace(/^\\/btn_add\\s*/i,"");
+  const args = raw.match(/\\"([^\\"]+)\\"|'([^']+)'|(\\S+)/g)?.map(s=>s.replace(/^['\\"]|['\\"]$/g,"")) || [];
+  if (args.length<3) return void safeCall(()=>ctx.reply('用法：/btn_add "显示文字" 链接 顺序'));
+  const [text,url,orderStr] = args; const order = Number(orderStr);
+  if (!isValidUrl(url)||Number.isNaN(order)) return void safeCall(()=>ctx.reply("❌ 参数不合法"));
+  buttons.push({ text, url, order }); await store.setButtons(buttons);
+  await safeCall(()=>ctx.reply("✅ 已添加")); const kb = buildTrafficKeyboard(); if (kb) await safeCall(()=>ctx.reply("预览：", kb));
+});
+bot.command("btn_set", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const raw = (ctx.message as any).text.replace(/^\\/btn_set\\s*/i,"");
+  const args = raw.match(/\\"([^\\"]+)\\"|'([^']+)'|(\\S+)/g)?.map(s=>s.replace(/^['\\"]|['\\"]$/g,"")) || [];
+  if (args.length<4) return void safeCall(()=>ctx.reply('用法：/btn_set 序号 "显示文字" 链接 顺序'));
+  const [idxStr,text,url,orderStr] = args;
+  const idx = Number(idxStr)-1; const order = Number(orderStr);
+  const sorted = [...buttons].sort((a,b)=>a.order-b.order);
+  if (idx<0 || idx>=sorted.length || !isValidUrl(url) || Number.isNaN(order)) return void safeCall(()=>ctx.reply("❌ 参数不合法或序号越界"));
+  const target = sorted[idx]; const realIndex = buttons.findIndex(b=>b===target);
+  buttons[realIndex] = { text, url, order }; await store.setButtons(buttons);
+  await safeCall(()=>ctx.reply("✅ 已更新")); const kb = buildTrafficKeyboard(); if (kb) await safeCall(()=>ctx.reply("预览：", kb));
+});
+bot.command("btn_del", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const idx = Number((ctx.message as any).text.replace(/^\\/btn_del\\s*/i,"").trim())-1;
+  const sorted = [...buttons].sort((a,b)=>a.order-b.order);
+  if (Number.isNaN(idx)||idx<0||idx>=sorted.length) return void safeCall(()=>ctx.reply("用法：/btn_del 序号"));
+  const target = sorted[idx]; buttons = buttons.filter(b=>b!==target); await store.setButtons(buttons);
+  await safeCall(()=>ctx.reply("✅ 已删除"));
+  const kb = buildTrafficKeyboard(); if (kb) await safeCall(()=>ctx.reply("预览：", kb)); else await safeCall(()=>ctx.reply("（已空）"));
+});
+
+// Templates
+bot.command("adtpl_list", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  if (templates.length===0) return void safeCall(()=>ctx.reply("（空）没有广告模板"));
+  const lines = templates.map((t,i)=>`${i+1}. ${t.name}  thr=${t.threshold}`);
+  await safeCall(()=>ctx.reply("当前广告模板：\\n"+lines.join("\\n")));
+});
+bot.command("adtpl_add", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const raw = (ctx.message as any).text.replace(/^\\/adtpl_add\\s*/i,"");
+  const args = raw.match(/\\"([^\\"]+)\\"|'([^']+)'|(\\S+)/g)?.map(s=>s.replace(/^['\\"]|['\\"]$/g,"")) || [];
+  if (args.length<2) return void safeCall(()=>ctx.reply('用法：/adtpl_add "名称" "模板内容" [阈值(0~1)]'));
+  const [name, content, thrRaw] = args; const thr = thrRaw!==undefined ? Number(thrRaw): cfg.adtplDefaultThreshold;
+  if (Number.isNaN(thr)||thr<0||thr>1) return void safeCall(()=>ctx.reply("❌ 阈值应在 0~1 之间"));
+  templates.push({ name, content, threshold: thr }); await store.setTemplates(templates);
+  await safeCall(()=>ctx.reply(`✅ 已添加：${name}（thr=${thr}）`));
+});
+bot.command("adtpl_set", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const raw = (ctx.message as any).text.replace(/^\\/adtpl_set\\s*/i,"");
+  const args = raw.match(/\\"([^\\"]+)\\"|'([^']+)'|(\\S+)/g)?.map(s=>s.replace(/^['\\"]|['\\"]$/g,"")) || [];
+  if (args.length<4) return void safeCall(()=>ctx.reply('用法：/adtpl_set 序号 "名称" "模板内容" 阈值(0~1)'));
+  const [idxStr,name,content,thrRaw] = args; const idx = Number(idxStr)-1; const thr = Number(thrRaw);
+  if (Number.isNaN(idx)||idx<0||idx>=templates.length) return void safeCall(()=>ctx.reply("❌ 序号越界"));
+  if (Number.isNaN(thr)||thr<0||thr>1) return void safeCall(()=>ctx.reply("❌ 阈值应在 0~1 之间"));
+  templates[idx] = { name, content, threshold: thr }; await store.setTemplates(templates);
+  await safeCall(()=>ctx.reply(`✅ 已更新 #${idx+1}`));
+});
+bot.command("adtpl_del", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const idx = Number((ctx.message as any).text.replace(/^\\/adtpl_del\\s*/i,"").trim())-1;
+  if (Number.isNaN(idx)||idx<0||idx>=templates.length) return void safeCall(()=>ctx.reply("用法：/adtpl_del 序号"));
+  const t = templates[idx]; templates.splice(idx,1); await store.setTemplates(templates);
+  await safeCall(()=>ctx.reply(`✅ 已删除：${t.name}`));
+});
+bot.command("adtpl_test", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const raw = (ctx.message as any).text.replace(/^\\/adtpl_test\\s*/i,"").trim();
+  if (!raw) return void safeCall(()=>ctx.reply('用法：/adtpl_test "任意文本"'));
+  const text = raw.replace(/^['\\"]|['\\"]$/g,"");
+  const norm = normalizeText(text); const a = ngrams(norm, norm.length>=3?3:2);
+  let best = { idx:-1, name:"", score:0, thr: cfg.adtplDefaultThreshold };
+  templates.forEach((tpl, i)=>{
+    const b = ngrams(normalizeText(tpl.content), tpl.content.length>=3?3:2);
+    const score = jaccard(a,b); if (score>best.score) best = { idx:i, name:tpl.name, score, thr: tpl.threshold };
+  });
+  if (best.idx>=0) await safeCall(()=>ctx.reply(`最佳匹配：#${best.idx+1} ${best.name}  score=${best.score.toFixed(3)}  thr=${best.thr}`));
+  else await safeCall(()=>ctx.reply("无模板"));
+});
+
+// Allow / Block
+bot.command("allow", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const id = Number((ctx.message as any).text.split(/\\s+/)[1]); if (!id) return void safeCall(()=>ctx.reply("用法：/allow <userId>"));
+  allowlistSet.add(id); await store.addAllow(id); await safeCall(()=>ctx.reply(`✅ 已加入白名单：${id}`));
+});
+bot.command("unallow", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const id = Number((ctx.message as any).text.split(/\\s+/)[1]); if (!id) return void safeCall(()=>ctx.reply("用法：/unallow <userId>"));
+  allowlistSet.delete(id); await store.removeAllow(id); await safeCall(()=>ctx.reply(`✅ 已移出白名单：${id}`));
+});
+bot.command("block", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const id = Number((ctx.message as any).text.split(/\\s+/)[1]); if (!id) return void safeCall(()=>ctx.reply("用法：/block <userId>"));
+  blocklistSet.add(id); await store.addBlock(id); await safeCall(()=>ctx.reply(`⛔ 已封禁：${id}`));
+});
+bot.command("unblock", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const id = Number((ctx.message as any).text.split(/\\s+/)[1]); if (!id) return void safeCall(()=>ctx.reply("用法：/unblock <userId>"));
+  blocklistSet.delete(id); await store.removeBlock(id); await safeCall(()=>ctx.reply(`✅ 已解封：${id}`));
+});
+
+/** ====== Forward ====== */
+async function forwardToTarget(ctx: Context, sourceChatId: number|string, messageId: number, fromId: number, approvedBy: number, suspected?: Suspected) {
+  await safeCall(()=>ctx.telegram.forwardMessage(Number(cfg.forwardTargetId), Number(sourceChatId), Number(messageId)));
+  if (cfg.attachButtonsToTargetMeta) {
+    const kb = buildTrafficKeyboard();
+    const meta = `📨 来自用户ID:${fromId}，已由管理员ID:${approvedBy} 审核通过` + (suspected ? `\\n⚠️ 模板命中：${suspected.template}（score=${suspected.score})` : "");
+    if (kb) await safeCall(()=>ctx.telegram.sendMessage(Number(cfg.forwardTargetId), meta, kb));
+    else await safeCall(()=>ctx.telegram.sendMessage(Number(cfg.forwardTargetId), meta));
+  }
+}
+
+/** ====== Startup ====== */
+(async () => {
+  await loadAll();
+  const WEBHOOK_URL = process.env.WEBHOOK_URL || "";
+  const PORT = Number(process.env.PORT || 3000);
+
+  if (WEBHOOK_URL) {
+    const path = "/webhook";
+    bot.telegram.setWebhook(`${WEBHOOK_URL}${path}`).then(()=>{
+      app.use(bot.webhookCallback(path));
+      console.log(`✅ Webhook set: ${WEBHOOK_URL}${path}`);
+    }).catch((e)=>{
+      console.error("设置 Webhook 失败，回退到轮询：", e);
+      bot.launch().then(()=>console.log("✅ Bot started (polling)"));
+    });
+  } else {
+    bot.launch().then(()=>console.log("✅ Bot started (polling)"));
+  }
+  app.listen(PORT, "0.0.0.0", ()=>console.log(`🌐 Listening on ${PORT} (/healthz)`));
+  process.once("SIGINT", ()=>bot.stop("SIGINT"));
+  process.once("SIGTERM", ()=>bot.stop("SIGTERM"));
+})();
