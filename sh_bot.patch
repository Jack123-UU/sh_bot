diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,12 @@
+node_modules
+dist
+.env
+.DS_Store
+npm-debug.log*
+yarn-error.log*
+pnpm-debug.log*
+/.idea
+/.vscode
+/data
+*.sqlite
+*.db
diff --git a/.env.example b/.env.example
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/.env.example
@@ -0,0 +1,20 @@
+# === Required ===
+TELEGRAM_BOT_TOKEN=123456:ABC-your-bot-token
+FORWARD_TARGET_ID=-1001234567890           # ç›®æ ‡é¢‘é“/ç¾¤/ç”¨æˆ·IDï¼ˆé¢‘é“å¸¸ä¸º -100 å¼€å¤´ï¼‰
+ADMIN_IDS=111111111,222222222              # é€—å·åˆ†éš”ç®¡ç†å‘˜IDï¼ˆéœ€å…ˆç§èŠå¯åŠ¨è¿‡æœºå™¨äººï¼‰
+
+# === Optional ===
+WEBHOOK_URL=https://your-app.onrender.com  # ä¸å¡«åˆ™ä½¿ç”¨è½®è¯¢ï¼ˆé•¿è½®è¯¢ï¼‰
+WELCOME_TEXT=ğŸ‘‹ æ¬¢è¿ï¼ç‚¹å‡»â€œå¼€å§‹â€æˆ–â€œèœå•â€
+ATTACH_BUTTONS_TO_TARGET_META=1            # å®¡æ ¸é€šè¿‡ååœ¨ç›®æ ‡é¢‘é“è¿½åŠ å¸¦æŒ‰é’®çš„è¯´æ˜
+PER_USER_COOLDOWN_MS=3000
+GLOBAL_MIN_TIME_MS=60
+ALLOWLIST_MODE=0                           # 1=å¼€å¯ç™½åå•æ¨¡å¼
+
+# === Persistence ===
+PERSIST_BACKEND=redis                      # redis | sqlite
+REDIS_URL=redis://default:password@host:6379/0
+SQLITE_PATH=/data/bot.db                   # ä½¿ç”¨æŒä¹…åŒ–ç£ç›˜æŒ‚è½½åˆ° /data
+REVIEW_TARGET_ID=-1009999999999            # ï¼ˆå¯é€‰ï¼‰å®¡æ ¸é¢‘é“/ç¾¤/ç§äººIDï¼›ç•™ç©ºåˆ™é€ä¸ªå‘ç»™ ADMIN_IDS
+ADTPL_DEFAULT_THRESHOLD=0.6                # æ¨¡æ¿é»˜è®¤é˜ˆå€¼ï¼ˆ0~1ï¼‰
+
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/README.md
@@ -0,0 +1,86 @@
+# Telegram Moderated Forward Bot (Redis/SQLite)
+
+ä¸€ä¸ªå¯åœ¨ Render éƒ¨ç½²çš„ Telegram æœºå™¨äººï¼š
+- å®¡æ ¸è½¬å‘ï¼ˆç®¡ç†å‘˜é€šè¿‡åè½¬å‘åˆ°ç›®æ ‡é¢‘é“ï¼‰
+- å®¡æ ¸é¢‘é“ï¼ˆREVIEW_TARGET_IDï¼‰ç»Ÿä¸€æ”¶å®¡
+- å¼•æµæŒ‰é’®ï¼ˆç®¡ç†å‘˜åœ¨ bot å†…ç¼–è¾‘ï¼‰
+- æ¬¢è¿è¯­ã€èœå•ï¼ˆå›å¤é”®ç›˜ + inline é”®ç›˜ï¼‰
+- æ¨¡ç³Šå¹¿å‘Šæ¨¡æ¿æ£€æµ‹ï¼ˆ3-gram Jaccardï¼‰
+- é€Ÿç‡é™åˆ¶ï¼ˆå…¨å±€ + æ¯ç”¨æˆ·å†·å´ï¼‰
+- **æŒä¹…åŒ–ï¼šRedis æˆ– SQLiteï¼ˆäºŒé€‰ä¸€ï¼‰**
+
+## ç¯å¢ƒå˜é‡
+è§ `.env.example`ã€‚
+
+- Redisï¼šè®¾ç½® `PERSIST_BACKEND=redis` ä¸”æä¾› `REDIS_URL`
+- SQLiteï¼šè®¾ç½® `PERSIST_BACKEND=sqlite` ä¸”æä¾› `SQLITE_PATH`ï¼ˆæŒ‚è½½æŒä¹…åŒ–ç£ç›˜åˆ°è¯¥è·¯å¾„æ‰€åœ¨ç›®å½•ï¼‰
+
+## Render é…ç½®
+- Build: `npm ci && npm run build`
+- Start: `npm run start`
+- Health Check Path: `/healthz`
+
+## ç®¡ç†å‘½ä»¤ï¼ˆåœ¨ Telegram å†…ï¼‰
+- `/config` æŸ¥çœ‹é…ç½®
+- `/set_review_target <id>` è®¾ç½®å®¡æ ¸é¢‘é“/ç¾¤/ç”¨æˆ· IDï¼ˆç•™ç©ºå…³é—­â†’é€ä¸ªå‘ç®¡ç†å‘˜ï¼‰
+- `/set_target <id>` è®¾ç½®æœ€ç»ˆè½¬å‘ç›®æ ‡ ID
+- `/set_welcome <æ–‡æœ¬>` è®¾ç½®æ¬¢è¿è¯­
+- `/set_attach_buttons 1|0` å®¡æ ¸é€šè¿‡åçš„è¯´æ˜æ˜¯å¦é™„å¸¦å¼•æµæŒ‰é’®
+- `/set_rate <per_user_ms> <global_min_ms>` é€Ÿç‡å‚æ•°ï¼ˆå»ºè®®é‡å¯åæ›´ç¨³ï¼‰
+- `/toggle_allowlist 1|0` ç™½åå•æ¨¡å¼å¼€å…³
+- `/admins_list` `/admins_add <id>` `/admins_del <id>` ç®¡ç†ç®¡ç†å‘˜åˆ—è¡¨
+
+### å¼•æµæŒ‰é’®
+- `/btn_list`
+- `/btn_add "æ˜¾ç¤ºæ–‡å­—" https://é“¾æ¥ é¡ºåº`
+- `/btn_set åºå· "æ˜¾ç¤ºæ–‡å­—" https://é“¾æ¥ é¡ºåº`
+- `/btn_del åºå·`
+
+### å¹¿å‘Šæ¨¡æ¿
+- `/adtpl_list`
+- `/adtpl_add "åç§°" "æ¨¡æ¿å†…å®¹" 0.6`
+- `/adtpl_set åºå· "åç§°" "æ¨¡æ¿å†…å®¹" 0.7`
+- `/adtpl_del åºå·`
+- `/adtpl_test "ä»»æ„æ–‡æœ¬"`
+
+## å®¡æ ¸æµç¨‹
+éç®¡ç†å‘˜æ¶ˆæ¯ â†’ å…¥å¾…å®¡é˜Ÿåˆ— â†’ å‘é€â€œåŸæ¶ˆæ¯ + å®¡æ ¸æŒ‰é’®â€åˆ° `REVIEW_TARGET_ID`ï¼ˆè‹¥è®¾ç½®ï¼‰æˆ–é€ä¸ªç®¡ç†å‘˜ â†’ é€šè¿‡/æ‹’ç»/å°ç¦ã€‚é€šè¿‡åå°†åŸæ¶ˆæ¯è½¬å‘åˆ° `FORWARD_TARGET_ID`ã€‚
+
+## æƒé™
+åªæœ‰ç®¡ç†å‘˜ï¼ˆ`ADMIN_IDS` åˆå§‹ + åç»­é€šè¿‡å‘½ä»¤ç»´æŠ¤ï¼‰èƒ½æ‰§è¡Œé…ç½®ä¸å®¡æ ¸æŒ‰é’®æ“ä½œã€‚
+
+## æ³¨æ„
+- ç›®æ ‡ä¸ºé¢‘é“æ—¶å¿…é¡»å°†æœºå™¨äººè®¾ä¸ºç®¡ç†å‘˜
+- è‹¥è¦æ¥æ”¶ç¾¤æ™®é€šæ¶ˆæ¯ï¼ŒBotFather `/setprivacy` å…³é—­éšç§æ¨¡å¼
+- å¦‚æœä½¿ç”¨ SQLiteï¼ŒåŠ¡å¿…åœ¨ Render ä¸Šç»™è¯¥ Web æœåŠ¡æŒ‚è½½ **Persistent Disk**ï¼Œå¹¶å°† `SQLITE_PATH` æŒ‡å‘ç£ç›˜ç›®å½•ä¸‹çš„ db æ–‡ä»¶ï¼ˆä¾‹å¦‚ `/data/bot.db`ï¼‰ã€‚
+
diff --git a/package.json b/package.json
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/package.json
@@ -0,0 +1,38 @@
+{
+  "name": "tg-mod-forward-bot",
+  "version": "1.0.0",
+  "private": true,
+  "description": "Telegram moderated forward bot with Redis/SQLite persistence for Render.",
+  "engines": { "node": "20.x" },
+  "main": "dist/index.js",
+  "scripts": {
+    "build": "rimraf dist && tsc -p tsconfig.json",
+    "start": "node dist/index.js"
+  },
+  "dependencies": {
+    "telegraf": "^4.16.3",
+    "express": "^4.19.2",
+    "bottleneck": "^2.19.5",
+    "dotenv": "^16.4.5",
+    "ioredis": "^5.4.1",
+    "better-sqlite3": "^9.5.0"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.3",
+    "rimraf": "^6.0.1",
+    "@types/node": "^20.14.10",
+    "@types/express": "^4.17.21"
+  }
+}
diff --git a/tsconfig.json b/tsconfig.json
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/tsconfig.json
@@ -0,0 +1,21 @@
+{
+  "compilerOptions": {
+    "target": "ES2020",
+    "module": "CommonJS",
+    "moduleResolution": "node",
+    "outDir": "dist",
+    "rootDir": "src",
+    "esModuleInterop": true,
+    "resolveJsonModule": true,
+    "skipLibCheck": true,
+    "forceConsistentCasingInFileNames": true,
+    "strict": true
+  },
+  "include": ["src"]
+}
diff --git a/src/types.ts b/src/types.ts
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/src/types.ts
@@ -0,0 +1,24 @@
+export type TrafficBtn = { text: string; url: string; order: number };
+export type AdTemplate = { name: string; content: string; threshold: number };
+export type Suspected = { template: string; score: number };
+
+export type Req = {
+  id: string;
+  sourceChatId: number | string;
+  messageId: number;
+  fromId: number;
+  fromName: string;
+  createdAt: number;
+  suspected?: Suspected;
+};
+
+export type Config = {
+  forwardTargetId: string;     // ç›®æ ‡è½¬å‘ID
+  reviewTargetId?: string;     // å®¡æ ¸é¢‘é“/ç¾¤/ç§äºº
+  welcomeText: string;
+  attachButtonsToTargetMeta: boolean;
+  adminIds: string[];
+  allowlistMode: boolean;
+  adtplDefaultThreshold: number;
+};
diff --git a/src/store.ts b/src/store.ts
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/src/store.ts
@@ -0,0 +1,258 @@
+import type { Config, TrafficBtn, AdTemplate, Req } from "./types";
+import Redis from "ioredis";
+import Database from "better-sqlite3";
+
+export interface Store {
+  init(): Promise<void>;
+  // config
+  getConfig(): Promise<Config>;
+  setConfig(partial: Partial<Config>): Promise<void>;
+  // buttons
+  listButtons(): Promise<TrafficBtn[]>;
+  setButtons(btns: TrafficBtn[]): Promise<void>;
+  // templates
+  listTemplates(): Promise<AdTemplate[]>;
+  setTemplates(templates: AdTemplate[]): Promise<void>;
+  // allow/block lists
+  listAllow(): Promise<number[]>;
+  addAllow(id: number): Promise<void>;
+  removeAllow(id: number): Promise<void>;
+  listBlock(): Promise<number[]>;
+  addBlock(id: number): Promise<void>;
+  removeBlock(id: number): Promise<void>;
+  // pending queue
+  getPending(id: string): Promise<Req | null>;
+  setPending(req: Req): Promise<void>;
+  delPending(id: string): Promise<void>;
+}
+
+function defaultConfig(env: NodeJS.ProcessEnv): Config {
+  return {
+    forwardTargetId: env.FORWARD_TARGET_ID || "",
+    reviewTargetId: env.REVIEW_TARGET_ID || "",
+    welcomeText: env.WELCOME_TEXT || "ğŸ‘‹ æ¬¢è¿ï¼ç‚¹å‡»å·¦ä¸‹è§’â€œå¼€å§‹â€æˆ–ä½¿ç”¨èœå•æŒ‰é’®",
+    attachButtonsToTargetMeta: (env.ATTACH_BUTTONS_TO_TARGET_META || "1") === "1",
+    adminIds: (env.ADMIN_IDS || "").split(",").map(s => s.trim()).filter(Boolean),
+    allowlistMode: (env.ALLOWLIST_MODE || "0") === "1",
+    adtplDefaultThreshold: Math.min(1, Math.max(0, Number(env.ADTPL_DEFAULT_THRESHOLD ?? 0.6)))
+  };
+}
+
+/* ---------------- Redis Store ---------------- */
+export class RedisStore implements Store {
+  private r: Redis;
+  private prefix: string;
+  constructor(url: string, prefix = "tgmod") {
+    this.r = new Redis(url);
+    this.prefix = prefix;
+  }
+  async init() {
+    // nothing
+  }
+  private k(key: string) { return `${this.prefix}:${key}`; }
+
+  async getConfig(): Promise<Config> {
+    const raw = await this.r.get(this.k("config"));
+    if (raw) return JSON.parse(raw);
+    const cfg = defaultConfig(process.env);
+    await this.setConfig(cfg);
+    return cfg;
+  }
+  async setConfig(partial: Partial<Config> | Config) {
+    const current = await this.getConfig();
+    const next = { ...current, ...partial };
+    await this.r.set(this.k("config"), JSON.stringify(next));
+  }
+
+  async listButtons(): Promise<TrafficBtn[]> {
+    const raw = await this.r.get(this.k("buttons"));
+    return raw ? JSON.parse(raw) : [];
+  }
+  async setButtons(btns: TrafficBtn[]) {
+    await this.r.set(this.k("buttons"), JSON.stringify(btns));
+  }
+
+  async listTemplates(): Promise<AdTemplate[]> {
+    const raw = await this.r.get(this.k("templates"));
+    return raw ? JSON.parse(raw) : [];
+  }
+  async setTemplates(tpls: AdTemplate[]) {
+    await this.r.set(this.k("templates"), JSON.stringify(tpls));
+  }
+
+  async listAllow(): Promise<number[]> {
+    const members = await this.r.smembers(this.k("allowlist"));
+    return members.map(Number);
+  }
+    async addAllow(id: number) { await this.r.sadd(this.k("allowlist"), id.toString()); }
+  async removeAllow(id: number) { await this.r.srem(this.k("allowlist"), id.toString()); }
+
+  async listBlock(): Promise<number[]> {
+    const members = await this.r.smembers(this.k("blocklist"));
+    return members.map(Number);
+  }
+  async addBlock(id: number) { await this.r.sadd(this.k("blocklist"), id.toString()); }
+  async removeBlock(id: number) { await this.r.srem(this.k("blocklist"), id.toString()); }
+
+  async getPending(id: string): Promise<Req | null> {
+    const raw = await this.r.hget(this.k("pending"), id);
+    return raw ? JSON.parse(raw) : null;
+  }
+  async setPending(req: Req) {
+    await this.r.hset(this.k("pending"), { [req.id]: JSON.stringify(req) });
+  }
+  async delPending(id: string) {
+    await this.r.hdel(this.k("pending"), id);
+  }
+}
+
+/* ---------------- SQLite Store ---------------- */
+export class SqliteStore implements Store {
+  private db: Database.Database;
+  constructor(path: string) {
+    this.db = new Database(path);
+  }
+  async init() {
+    this.db.exec(`
+      CREATE TABLE IF NOT EXISTS config (
+        key TEXT PRIMARY KEY,
+        value TEXT NOT NULL
+      );
+      CREATE TABLE IF NOT EXISTS buttons (
+        id INTEGER PRIMARY KEY AUTOINCREMENT,
+        text TEXT NOT NULL,
+        url TEXT NOT NULL,
+        ord INTEGER NOT NULL
+      );
+      CREATE TABLE IF NOT EXISTS templates (
+        id INTEGER PRIMARY KEY AUTOINCREMENT,
+        name TEXT NOT NULL,
+        content TEXT NOT NULL,
+        threshold REAL NOT NULL
+      );
+      CREATE TABLE IF NOT EXISTS allowlist (user_id INTEGER PRIMARY KEY);
+      CREATE TABLE IF NOT EXISTS blocklist (user_id INTEGER PRIMARY KEY);
+      CREATE TABLE IF NOT EXISTS pending (
+        id TEXT PRIMARY KEY,
+        sourceChatId TEXT NOT NULL,
+        messageId INTEGER NOT NULL,
+        fromId INTEGER NOT NULL,
+        fromName TEXT NOT NULL,
+        createdAt INTEGER NOT NULL,
+        suspected_template TEXT,
+        suspected_score REAL
+      );
+    `);
+    // seed config if empty
+    const row = this.db.prepare("SELECT value FROM config WHERE key='config'").get();
+    if (!row) {
+      const cfg = defaultConfig(process.env);
+      this.db.prepare("INSERT INTO config (key, value) VALUES ('config', ?)").run(JSON.stringify(cfg));
+    }
+  }
+
+  async getConfig(): Promise<Config> {
+    const row = this.db.prepare("SELECT value FROM config WHERE key='config'").get();
+    if (row?.value) return JSON.parse(row.value);
+    const cfg = defaultConfig(process.env);
+    await this.setConfig(cfg);
+    return cfg;
+  }
+  async setConfig(partial: Partial<Config> | Config) {
+    const current = await this.getConfig();
+    const next = { ...current, ...partial };
+    this.db.prepare("INSERT INTO config(key, value) VALUES ('config', ?) ON CONFLICT(key) DO UPDATE SET value=excluded.value").run(JSON.stringify(next));
+  }
+
+  async listButtons(): Promise<TrafficBtn[]> {
+    const rows = this.db.prepare("SELECT text, url, ord AS 'order' FROM buttons ORDER BY ord ASC").all();
+    return rows as TrafficBtn[];
+  }
+  async setButtons(btns: TrafficBtn[]) {
+    const trx = this.db.transaction((arr: TrafficBtn[]) => {
+      this.db.prepare("DELETE FROM buttons").run();
+      const stmt = this.db.prepare("INSERT INTO buttons(text, url, ord) VALUES (?, ?, ?)");
+      for (const b of arr) stmt.run(b.text, b.url, b.order);
+    });
+    trx(btns);
+  }
+
+  async listTemplates(): Promise<AdTemplate[]> {
+    const rows = this.db.prepare("SELECT name, content, threshold FROM templates ORDER BY id ASC").all();
+    return rows as AdTemplate[];
+  }
+  async setTemplates(tpls: AdTemplate[]) {
+    const trx = this.db.transaction((arr: AdTemplate[]) => {
+      this.db.prepare("DELETE FROM templates").run();
+      const stmt = this.db.prepare("INSERT INTO templates(name, content, threshold) VALUES (?, ?, ?)");
+      for (const t of arr) stmt.run(t.name, t.content, t.threshold);
+    });
+    trx(tpls);
+  }
+
+  async listAllow(): Promise<number[]> {
+    return this.db.prepare("SELECT user_id FROM allowlist").all().map((r: any) => r.user_id);
+  }
+  async addAllow(id: number) { this.db.prepare("INSERT OR IGNORE INTO allowlist(user_id) VALUES (?)").run(id); }
+  async removeAllow(id: number) { this.db.prepare("DELETE FROM allowlist WHERE user_id=?").run(id); }
+
+  async listBlock(): Promise<number[]> {
+    return this.db.prepare("SELECT user_id FROM blocklist").all().map((r: any) => r.user_id);
+  }
+  async addBlock(id: number) { this.db.prepare("INSERT OR IGNORE INTO blocklist(user_id) VALUES (?)").run(id); }
+  async removeBlock(id: number) { this.db.prepare("DELETE FROM blocklist WHERE user_id=?").run(id); }
+
+  async getPending(id: string): Promise<Req | null> {
+    const r = this.db.prepare("SELECT * FROM pending WHERE id=?").get(id);
+    if (!r) return null;
+    const req: Req = {
+      id: r.id,
+      sourceChatId: isNaN(Number(r.sourceChatId)) ? r.sourceChatId : Number(r.sourceChatId),
+      messageId: r.messageId,
+      fromId: r.fromId,
+      fromName: r.fromName,
+      createdAt: r.createdAt,
+      suspected: r.suspected_template ? { template: r.suspected_template, score: r.suspected_score } : undefined
+    };
+    return req;
+  }
+  async setPending(req: Req) {
+    this.db.prepare(`INSERT OR REPLACE INTO pending(id, sourceChatId, messageId, fromId, fromName, createdAt, suspected_template, suspected_score)
+      VALUES (?, ?, ?, ?, ?, ?, ?, ?)`)
+      .run(req.id, String(req.sourceChatId), req.messageId, req.fromId, req.fromName, req.createdAt, req.suspected?.template ?? null, req.suspected?.score ?? null);
+  }
+  async delPending(id: string) {
+    this.db.prepare("DELETE FROM pending WHERE id=?").run(id);
+  }
+}
+
+export function buildStore(): Store {
+  const backend = (process.env.PERSIST_BACKEND || "redis").toLowerCase();
+  if (backend === "sqlite") {
+    const path = process.env.SQLITE_PATH || "./data/bot.db";
+    return new SqliteStore(path);
+  }
+  const url = process.env.REDIS_URL || "redis://127.0.0.1:6379/0";
+  return new RedisStore(url);
+}
diff --git a/src/index.ts b/src/index.ts
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/src/index.ts
@@ -0,0 +1,694 @@
+import "dotenv/config";
+import express from "express";
+import Bottleneck from "bottleneck";
+import { Telegraf, Markup, Context } from "telegraf";
+import type { TrafficBtn, AdTemplate, Req, Config, Suspected } from "./types";
+import { buildStore, Store } from "./store";
+
+/** ====== Boot ====== */
+const TOKEN = process.env.TELEGRAM_BOT_TOKEN!;
+if (!TOKEN) throw new Error("ç¼ºå°‘ TELEGRAM_BOT_TOKEN");
+const bot = new Telegraf(TOKEN);
+const app = express();
+app.use(express.json());
+
+// Health check
+app.get("/healthz", (_req, res) => res.status(200).send("ok"));
+
+// Limits
+const PER_USER_COOLDOWN_MS = Number(process.env.PER_USER_COOLDOWN_MS || 3000);
+const GLOBAL_MIN_TIME_MS = Number(process.env.GLOBAL_MIN_TIME_MS || 60);
+const limiter = new Bottleneck({ minTime: GLOBAL_MIN_TIME_MS, maxConcurrent: 1 });
+const safeCall = async <T,>(fn: () => Promise<T>): Promise<T | undefined> => {
+  try { return await limiter.schedule(fn); } catch (e) { console.error(e); return; }
+};
+
+/** ====== Store & Config ====== */
+const store: Store = buildStore();
+let cfg: Config;
+let buttons: TrafficBtn[] = [];
+let templates: AdTemplate[] = [];
+let allowlistSet = new Set<number>();
+let blocklistSet = new Set<number>();
+let allowlistMode = false;
+
+// Dedup & user cooldown (in-memory)
+const dedup = new Map<string, number>();
+const userCooldown = new Map<number, number>();
+
+function isAdmin(id?: number) { return !!id && cfg.adminIds.includes(String(id)); }
+function buildTrafficKeyboard() {
+  if (buttons.length === 0) return undefined;
+  const sorted = [...buttons].sort((a,b)=>a.order-b.order);
+  const rows: any[] = [];
+  for (let i=0; i<sorted.length; i+=2) rows.push(sorted.slice(i,i+2).map(b=>Markup.button.url(b.text,b.url)));
+  return Markup.inlineKeyboard(rows);
+}
+function buildReplyKeyboard() { return Markup.keyboard([["å¼€å§‹","èœå•"]]).resize(true).oneTime(false); }
+
+function human(u?: { username?: string; first_name?: string; last_name?: string; id?: number }) {
+  if (!u) return "æœªçŸ¥ç”¨æˆ·";
+  const name = [u.first_name, u.last_name].filter(Boolean).join(" ").trim();
+  return u.username ? `@${u.username}` : (name || `ID:${u.id}`);
+}
+function parseArgsQuoted(s: string): string[] {
+  const out: string[] = []; const re = /"([^"]+)"|'([^']+)'|(\\S+)/g; let m: RegExpExecArray | null;
+  while ((m = re.exec(s))) out.push(m[1] || m[2] || m[3]);
+  return out;
+}
+function isValidUrl(u: string) { return /^https?:\\/\\/\\S+/i.test(u); }
+
+// normalize & n-gram
+function toHalfWidth(str: string): string {
+  return str.replace(/[\\uFF01-\\uFF5E]/g, (ch) => String.fromCharCode(ch.charCodeAt(0) - 0xFEE0)).replace(/\\u3000/g, " ");
+}
+function normalizeText(s: string): string {
+  const lower = toHalfWidth(s).toLowerCase();
+  const stripped = lower.replace(/[^\\p{Letter}\\p{Number}\\u4e00-\\u9fa5]+/gu, "");
+  return stripped;
+}
+function ngrams(s: string, n: number): Set<string> {
+  const set = new Set<string>(); if (!s) return set;
+  const N = Math.max(1, Math.min(n, s.length));
+  for (let i=0;i<=s.length-N;i++) set.add(s.slice(i,i+N));
+  return set;
+}
+function jaccard(a: Set<string>, b: Set<string>): number {
+  if (a.size===0 && b.size===0) return 1; let inter=0;
+  for (const x of a) if (b.has(x)) inter++; const uni=a.size+b.size-inter;
+  return uni===0?0:inter/uni;
+}
+function detectAdTemplate(text: string): { matched: boolean; name?: string; score?: number } {
+  const norm = normalizeText(text); if (!norm) return { matched:false };
+  const a = ngrams(norm, norm.length >=3 ? 3 : 2);
+  let best = { name: "", score: 0, thr: cfg.adtplDefaultThreshold };
+  for (const tpl of templates) {
+    const b = ngrams(normalizeText(tpl.content), tpl.content.length>=3?3:2);
+    const score = jaccard(a,b);
+    const thr = Math.max(0, Math.min(1, tpl.threshold ?? cfg.adtplDefaultThreshold));
+    if (score>=thr && score>best.score) best = { name: tpl.name, score, thr };
+  }
+  if (best.score >= (best.thr || cfg.adtplDefaultThreshold)) return { matched:true, name:best.name, score:Number(best.score.toFixed(3)) };
+  return { matched:false };
+}
+
+function extractMessageText(msg: any): string {
+  return (msg?.text ?? msg?.caption ?? "").toString();
+}
+
+async function loadAll() {
+  await store.init();
+  cfg = await store.getConfig();
+  buttons = await store.listButtons();
+  templates = await store.listTemplates();
+  allowlistSet = new Set(await store.listAllow());
+  blocklistSet = new Set(await store.listBlock());
+  allowlistMode = cfg.allowlistMode;
+  if (!cfg.forwardTargetId) throw new Error("é…ç½®ç¼ºå°‘ forwardTargetIdï¼ˆFORWARD_TARGET_IDï¼‰");
+}
+
+/** ====== Welcome/Menu ====== */
+async function showWelcome(ctx: Context) {
+  await safeCall(() => (ctx as any).reply(cfg.welcomeText, buildReplyKeyboard()));
+  const kb = buildTrafficKeyboard();
+  if (kb) await safeCall(() => (ctx as any).reply("ğŸ‘‡ ç²¾é€‰å¯¼èˆª", kb));
+}
+bot.start((ctx)=>showWelcome(ctx));
+bot.hears(/^å¼€å§‹$/i, (ctx)=>showWelcome(ctx));
+bot.hears(/^èœå•$/i, (ctx)=>{
+  const kb = buildTrafficKeyboard();
+  if (kb) return void safeCall(()=>ctx.reply("ğŸ‘‡ èœå• / å¯¼èˆª", kb));
+  return void safeCall(()=>ctx.reply("æš‚æ— èœå•æŒ‰é’®ï¼Œç®¡ç†å‘˜å¯ç”¨ã€Œæ·»åŠ æŒ‰é’®ã€å‘½ä»¤æ–°å¢ã€‚"));
+});
+
+/** ====== Main message handler (moderation flow) ====== */
+bot.on("message", async (ctx) => {
+  const fromId = ctx.from?.id; const chatId = ctx.chat?.id; const mid = (ctx.message as any)?.message_id;
+  if (!fromId || !chatId || !mid) return;
+
+  // Block/Allow
+  if (blocklistSet.has(fromId)) return;
+  if (allowlistMode && !allowlistSet.has(fromId) && !isAdmin(fromId)) {
+    await safeCall(()=>ctx.reply("ğŸš« æœªåœ¨ç™½åå•ï¼Œæ¶ˆæ¯ä¸äºˆå¤„ç†"));
+    return;
+  }
+  // dedup
+  const key = `${chatId}:${mid}`; const now = Date.now();
+  if ((dedup.get(key)||0) + 1000 > now) return;
+  dedup.set(key, now);
+  for (const [k, ts] of dedup) if (now - ts > 60_000) dedup.delete(k);
+  // cooldown
+  const lastTs = userCooldown.get(fromId) || 0;
+  if (!isAdmin(fromId) && now - lastTs < PER_USER_COOLDOWN_MS) {
+    await safeCall(()=>ctx.reply(`â³ ä½ å‘å¤ªå¿«äº†ï¼Œè¯· ${Math.ceil((PER_USER_COOLDOWN_MS - (now - lastTs))/1000)}s åé‡è¯•`));
+    return;
+  }
+  userCooldown.set(fromId, now);
+
+  // Admin bypass
+  if (isAdmin(fromId)) {
+    await forwardToTarget(ctx, chatId, mid, fromId, fromId, undefined);
+    return;
+  }
+
+  // Detect template
+  const txt = extractMessageText(ctx.message);
+  const hit = detectAdTemplate(txt);
+
+  // Enqueue pending
+  const id = `${now}_${chatId}_${mid}`;
+  const req: Req = { id, sourceChatId: chatId, messageId: mid, fromId, fromName: human(ctx.from), createdAt: now,
+    suspected: hit.matched ? { template: hit.name!, score: hit.score! } : undefined
+  };
+  await store.setPending(req);
+  await safeCall(()=>ctx.reply(hit.matched ? `ğŸ“ å·²æäº¤å®¡æ ¸ï¼ˆâš ï¸ ç–‘ä¼¼æ¨¡æ¿ï¼š${req.suspected!.template}ï¼Œscore=${req.suspected!.score}ï¼‰` : "ğŸ“ å·²æäº¤å®¡æ ¸ï¼Œè¯·ç­‰å¾…ç®¡ç†å‘˜å¤„ç†"));
+
+  // Send to review target or admins
+  const reviewText = `ğŸ•µï¸ å®¡æ ¸è¯·æ±‚ #${id}
+æ¥è‡ªï¼š${req.fromName} (ID:${fromId})
+æ¥æº chatId: ${chatId}` + (hit.matched ? `
+âš ï¸ ç–‘ä¼¼å¹¿å‘Šæ¨¡æ¿ï¼š${hit.name}ï¼ˆscore=${hit.score}ï¼‰` : "");
+
+  const kb = Markup.inlineKeyboard([
+    [Markup.button.callback("âœ… é€šè¿‡", `approve:${id}`), Markup.button.callback("âŒ æ‹’ç»", `reject:${id}`)],
+    [Markup.button.callback("â›” å°ç¦æ­¤äºº", `ban:${fromId}`)]
+  ]);
+
+  if (cfg.reviewTargetId) {
+    await safeCall(()=>ctx.telegram.forwardMessage(Number(cfg.reviewTargetId), chatId, mid));
+    await safeCall(()=>ctx.telegram.sendMessage(Number(cfg.reviewTargetId), reviewText, kb));
+  } else {
+    for (const admin of cfg.adminIds) {
+      await safeCall(()=>ctx.telegram.forwardMessage(Number(admin), chatId, mid));
+      await safeCall(()=>ctx.telegram.sendMessage(Number(admin), reviewText, kb));
+    }
+  }
+});
+
+/** ====== Callback (approve/reject/ban) ====== */
+bot.on("callback_query", async (ctx) => {
+  const cb: any = ctx.callbackQuery; const data: string = cb.data || ""; const adminId = ctx.from?.id;
+  if (!isAdmin(adminId)) { await safeCall(()=>ctx.answerCbQuery("æ— æƒæ“ä½œ",{show_alert:true})); return; }
+
+  if (data.startsWith("approve:")) {
+    const id = data.split(":")[1];
+    const req = await store.getPending(id); if (!req) { await safeCall(()=>ctx.answerCbQuery("è¯·æ±‚ä¸å­˜åœ¨æˆ–å·²å¤„ç†")); return; }
+    await forwardToTarget(ctx, req.sourceChatId, req.messageId, req.fromId, adminId!, req.suspected);
+    await store.delPending(id);
+    await safeCall(()=>ctx.editMessageText(`âœ… å·²é€šè¿‡ #${id} å¹¶è½¬å‘`));
+    await safeCall(()=>ctx.answerCbQuery("å·²é€šè¿‡"));
+  } else if (data.startsWith("reject:")) {
+    const id = data.split(":")[1];
+    const req = await store.getPending(id);
+    if (!req) { await safeCall(()=>ctx.answerCbQuery("è¯·æ±‚ä¸å­˜åœ¨æˆ–å·²å¤„ç†")); return; }
+    await store.delPending(id);
+    await safeCall(()=>ctx.editMessageText(`âŒ å·²æ‹’ç» #${id}`));
+    await safeCall(()=>ctx.answerCbQuery("å·²æ‹’ç»"));
+  } else if (data.startsWith("ban:")) {
+    const uid = Number(data.split(":")[1]);
+    blocklistSet.add(uid); await store.addBlock(uid);
+    await safeCall(()=>ctx.editMessageText(`â›” å·²å°ç¦ç”¨æˆ· ${uid}`));
+    await safeCall(()=>ctx.answerCbQuery("å·²å°ç¦"));
+  }
+});
+
+/** ====== Admin: config & buttons & templates ====== */
+function requireAdmin(ctx: any): boolean {
+  if (!isAdmin(ctx.from?.id)) { return false; }
+  return true;
+}
+// /config â€”â€” æŸ¥çœ‹å½“å‰é…ç½®
+bot.command("config", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const text = `âš™ï¸ é…ç½®
+forwardTargetId: ${cfg.forwardTargetId}
+reviewTargetId: ${cfg.reviewTargetId || "(æœªè®¾ç½®ï¼Œæ”¹ä¸ºé€ä¸ªå‘ç®¡ç†å‘˜)"}
+admins: ${cfg.adminIds.join(",")}
+welcomeText: ${cfg.welcomeText}
+attachButtonsToTargetMeta: ${cfg.attachButtonsToTargetMeta}
+allowlistMode: ${cfg.allowlistMode}
+adtplDefaultThreshold: ${cfg.adtplDefaultThreshold}
+æŒ‰é’®æ•°: ${buttons.length}ï¼Œæ¨¡æ¿æ•°: ${templates.length}`;
+  await safeCall(()=>ctx.reply(text));
+});
+
+bot.command("set_review_target", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const id = (ctx.message as any).text.replace(/^\\/set_review_target\\s*/i,"").trim();
+  cfg.reviewTargetId = id || "";
+  await store.setConfig({ reviewTargetId: cfg.reviewTargetId });
+  await safeCall(()=>ctx.reply(`âœ… å®¡æ ¸é¢‘é“å·²è®¾ç½®ä¸ºï¼š${cfg.reviewTargetId || "(å…³é—­ï¼Œé€ä¸ªå‘ç®¡ç†å‘˜)"}`));
+});
+
+bot.command("set_target", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const id = (ctx.message as any).text.replace(/^\\/set_target\\s*/i,"").trim();
+  if (!id) return void safeCall(()=>ctx.reply("ç”¨æ³•ï¼š/set_target <ID>"));
+  cfg.forwardTargetId = id;
+  await store.setConfig({ forwardTargetId: id });
+  await safeCall(()=>ctx.reply(`âœ… è½¬å‘ç›®æ ‡å·²æ›´æ–°ï¼š${id}`));
+});
+
+bot.command("set_welcome", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const text = (ctx.message as any).text.replace(/^\\/set_welcome\\s*/i,"").trim();
+  if (!text) return void safeCall(()=>ctx.reply("ç”¨æ³•ï¼š/set_welcome æ¬¢è¿è¯­æ–‡æœ¬"));
+  cfg.welcomeText = text;
+  await store.setConfig({ welcomeText: text });
+  await safeCall(()=>ctx.reply("âœ… æ¬¢è¿è¯­å·²æ›´æ–°")); await showWelcome(ctx);
+});
+
+bot.command("set_attach_buttons", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const v = (ctx.message as any).text.replace(/^\\/set_attach_buttons\\s*/i,"").trim();
+  if (!/^([01]|true|false)$/i.test(v)) return void safeCall(()=>ctx.reply("ç”¨æ³•ï¼š/set_attach_buttons 1|0"));
+  const flag = v === "1" || /^true$/i.test(v);
+  cfg.attachButtonsToTargetMeta = flag;
+  await store.setConfig({ attachButtonsToTargetMeta: flag });
+  await safeCall(()=>ctx.reply(`âœ… ç›®æ ‡è¯´æ˜é™„å¸¦æŒ‰é’®ï¼š${flag?"å¼€å¯":"å…³é—­"}`));
+});
+
+bot.command("set_rate", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const parts = (ctx.message as any).text.split(/\\s+/).slice(1);
+  if (parts.length<2) return void safeCall(()=>ctx.reply("ç”¨æ³•ï¼š/set_rate <per_user_ms> <global_min_ms>"));
+  const a = Number(parts[0]), b = Number(parts[1]);
+  if (Number.isNaN(a)||Number.isNaN(b)) return void safeCall(()=>ctx.reply("âŒ å‚æ•°å¿…é¡»ä¸ºæ•°å­—æ¯«ç§’"));
+  process.env.PER_USER_COOLDOWN_MS = String(a);
+  process.env.GLOBAL_MIN_TIME_MS = String(b);
+  await safeCall(()=>ctx.reply(`âœ… å·²è®¾ç½®ï¼šæ¯äººå†·å´ ${a} msï¼Œå…¨å±€æœ€å°é—´éš” ${b} ms\\nï¼ˆé‡å¯åç”Ÿæ•ˆæ›´ç¨³ï¼‰`));
+});
+
+bot.command("toggle_allowlist", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const v = (ctx.message as any).text.split(/\\s+/)[1];
+  if (!/^([01]|true|false)$/i.test(v)) return void safeCall(()=>ctx.reply("ç”¨æ³•ï¼š/toggle_allowlist 1|0"));
+  const flag = v==="1" || /^true$/i.test(v);
+  allowlistMode = flag; cfg.allowlistMode = flag;
+  await store.setConfig({ allowlistMode: flag });
+  await safeCall(()=>ctx.reply(`âœ… ç™½åå•æ¨¡å¼ï¼š${flag?"å¼€å¯":"å…³é—­"}`));
+});
+
+// Admins
+bot.command("admins_list", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  await safeCall(()=>ctx.reply("å½“å‰ç®¡ç†å‘˜ï¼š\\n" + cfg.adminIds.join("\\n")));
+});
+bot.command("admins_add", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const id = (ctx.message as any).text.split(/\\s+/)[1];
+  if (!id) return void safeCall(()=>ctx.reply("ç”¨æ³•ï¼š/admins_add <userId>"));
+  if (!cfg.adminIds.includes(id)) cfg.adminIds.push(id);
+  await store.setConfig({ adminIds: cfg.adminIds });
+  await safeCall(()=>ctx.reply(`âœ… å·²æ·»åŠ ç®¡ç†å‘˜ï¼š${id}`));
+});
+bot.command("admins_del", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const id = (ctx.message as any).text.split(/\\s+/)[1];
+  if (!id) return void safeCall(()=>ctx.reply("ç”¨æ³•ï¼š/admins_del <userId>"));
+  cfg.adminIds = cfg.adminIds.filter(x=>x!==id);
+  await store.setConfig({ adminIds: cfg.adminIds });
+  await safeCall(()=>ctx.reply(`âœ… å·²ç§»é™¤ç®¡ç†å‘˜ï¼š${id}`));
+});
+
+// Buttons
+bot.command("btn_list", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  if (buttons.length===0) return void safeCall(()=>ctx.reply("ï¼ˆç©ºï¼‰æ²¡æœ‰ä»»ä½•æŒ‰é’®"));
+  const sorted = [...buttons].sort((a,b)=>a.order-b.order);
+  const lines = sorted.map((b,i)=>`${i+1}. [${b.text}] ${b.url} ï¼ˆé¡ºåºï¼š${b.order}ï¼‰`);
+  await safeCall(()=>ctx.reply("å½“å‰æŒ‰é’®ï¼š\\n"+lines.join("\\n")));
+  const kb = buildTrafficKeyboard(); if (kb) await safeCall(()=>ctx.reply("é¢„è§ˆï¼š", kb));
+});
+bot.command("btn_add", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const raw = (ctx.message as any).text.replace(/^\\/btn_add\\s*/i,"");
+  const args = raw.match(/\\"([^\\"]+)\\"|'([^']+)'|(\\S+)/g)?.map(s=>s.replace(/^['\\"]|['\\"]$/g,"")) || [];
+  if (args.length<3) return void safeCall(()=>ctx.reply('ç”¨æ³•ï¼š/btn_add "æ˜¾ç¤ºæ–‡å­—" é“¾æ¥ é¡ºåº'));
+  const [text,url,orderStr] = args; const order = Number(orderStr);
+  if (!isValidUrl(url)||Number.isNaN(order)) return void safeCall(()=>ctx.reply("âŒ å‚æ•°ä¸åˆæ³•"));
+  buttons.push({ text, url, order }); await store.setButtons(buttons);
+  await safeCall(()=>ctx.reply("âœ… å·²æ·»åŠ ")); const kb = buildTrafficKeyboard(); if (kb) await safeCall(()=>ctx.reply("é¢„è§ˆï¼š", kb));
+});
+bot.command("btn_set", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const raw = (ctx.message as any).text.replace(/^\\/btn_set\\s*/i,"");
+  const args = raw.match(/\\"([^\\"]+)\\"|'([^']+)'|(\\S+)/g)?.map(s=>s.replace(/^['\\"]|['\\"]$/g,"")) || [];
+  if (args.length<4) return void safeCall(()=>ctx.reply('ç”¨æ³•ï¼š/btn_set åºå· "æ˜¾ç¤ºæ–‡å­—" é“¾æ¥ é¡ºåº'));
+  const [idxStr,text,url,orderStr] = args;
+  const idx = Number(idxStr)-1; const order = Number(orderStr);
+  const sorted = [...buttons].sort((a,b)=>a.order-b.order);
+  if (idx<0 || idx>=sorted.length || !isValidUrl(url) || Number.isNaN(order)) return void safeCall(()=>ctx.reply("âŒ å‚æ•°ä¸åˆæ³•æˆ–åºå·è¶Šç•Œ"));
+  const target = sorted[idx]; const realIndex = buttons.findIndex(b=>b===target);
+  buttons[realIndex] = { text, url, order }; await store.setButtons(buttons);
+  await safeCall(()=>ctx.reply("âœ… å·²æ›´æ–°")); const kb = buildTrafficKeyboard(); if (kb) await safeCall(()=>ctx.reply("é¢„è§ˆï¼š", kb));
+});
+bot.command("btn_del", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const idx = Number((ctx.message as any).text.replace(/^\\/btn_del\\s*/i,"").trim())-1;
+  const sorted = [...buttons].sort((a,b)=>a.order-b.order);
+  if (Number.isNaN(idx)||idx<0||idx>=sorted.length) return void safeCall(()=>ctx.reply("ç”¨æ³•ï¼š/btn_del åºå·"));
+  const target = sorted[idx]; buttons = buttons.filter(b=>b!==target); await store.setButtons(buttons);
+  await safeCall(()=>ctx.reply("âœ… å·²åˆ é™¤"));
+  const kb = buildTrafficKeyboard(); if (kb) await safeCall(()=>ctx.reply("é¢„è§ˆï¼š", kb)); else await safeCall(()=>ctx.reply("ï¼ˆå·²ç©ºï¼‰"));
+});
+
+// Templates
+bot.command("adtpl_list", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  if (templates.length===0) return void safeCall(()=>ctx.reply("ï¼ˆç©ºï¼‰æ²¡æœ‰å¹¿å‘Šæ¨¡æ¿"));
+  const lines = templates.map((t,i)=>`${i+1}. ${t.name}  thr=${t.threshold}`);
+  await safeCall(()=>ctx.reply("å½“å‰å¹¿å‘Šæ¨¡æ¿ï¼š\\n"+lines.join("\\n")));
+});
+bot.command("adtpl_add", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const raw = (ctx.message as any).text.replace(/^\\/adtpl_add\\s*/i,"");
+  const args = raw.match(/\\"([^\\"]+)\\"|'([^']+)'|(\\S+)/g)?.map(s=>s.replace(/^['\\"]|['\\"]$/g,"")) || [];
+  if (args.length<2) return void safeCall(()=>ctx.reply('ç”¨æ³•ï¼š/adtpl_add "åç§°" "æ¨¡æ¿å†…å®¹" [é˜ˆå€¼(0~1)]'));
+  const [name, content, thrRaw] = args; const thr = thrRaw!==undefined ? Number(thrRaw): cfg.adtplDefaultThreshold;
+  if (Number.isNaN(thr)||thr<0||thr>1) return void safeCall(()=>ctx.reply("âŒ é˜ˆå€¼åº”åœ¨ 0~1 ä¹‹é—´"));
+  templates.push({ name, content, threshold: thr }); await store.setTemplates(templates);
+  await safeCall(()=>ctx.reply(`âœ… å·²æ·»åŠ ï¼š${name}ï¼ˆthr=${thr}ï¼‰`));
+});
+bot.command("adtpl_set", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const raw = (ctx.message as any).text.replace(/^\\/adtpl_set\\s*/i,"");
+  const args = raw.match(/\\"([^\\"]+)\\"|'([^']+)'|(\\S+)/g)?.map(s=>s.replace(/^['\\"]|['\\"]$/g,"")) || [];
+  if (args.length<4) return void safeCall(()=>ctx.reply('ç”¨æ³•ï¼š/adtpl_set åºå· "åç§°" "æ¨¡æ¿å†…å®¹" é˜ˆå€¼(0~1)'));
+  const [idxStr,name,content,thrRaw] = args; const idx = Number(idxStr)-1; const thr = Number(thrRaw);
+  if (Number.isNaN(idx)||idx<0||idx>=templates.length) return void safeCall(()=>ctx.reply("âŒ åºå·è¶Šç•Œ"));
+  if (Number.isNaN(thr)||thr<0||thr>1) return void safeCall(()=>ctx.reply("âŒ é˜ˆå€¼åº”åœ¨ 0~1 ä¹‹é—´"));
+  templates[idx] = { name, content, threshold: thr }; await store.setTemplates(templates);
+  await safeCall(()=>ctx.reply(`âœ… å·²æ›´æ–° #${idx+1}`));
+});
+bot.command("adtpl_del", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const idx = Number((ctx.message as any).text.replace(/^\\/adtpl_del\\s*/i,"").trim())-1;
+  if (Number.isNaN(idx)||idx<0||idx>=templates.length) return void safeCall(()=>ctx.reply("ç”¨æ³•ï¼š/adtpl_del åºå·"));
+  const t = templates[idx]; templates.splice(idx,1); await store.setTemplates(templates);
+  await safeCall(()=>ctx.reply(`âœ… å·²åˆ é™¤ï¼š${t.name}`));
+});
+bot.command("adtpl_test", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const raw = (ctx.message as any).text.replace(/^\\/adtpl_test\\s*/i,"").trim();
+  if (!raw) return void safeCall(()=>ctx.reply('ç”¨æ³•ï¼š/adtpl_test "ä»»æ„æ–‡æœ¬"'));
+  const text = raw.replace(/^['\\"]|['\\"]$/g,"");
+  const norm = normalizeText(text); const a = ngrams(norm, norm.length>=3?3:2);
+  let best = { idx:-1, name:"", score:0, thr: cfg.adtplDefaultThreshold };
+  templates.forEach((tpl, i)=>{
+    const b = ngrams(normalizeText(tpl.content), tpl.content.length>=3?3:2);
+    const score = jaccard(a,b); if (score>best.score) best = { idx:i, name:tpl.name, score, thr: tpl.threshold };
+  });
+  if (best.idx>=0) await safeCall(()=>ctx.reply(`æœ€ä½³åŒ¹é…ï¼š#${best.idx+1} ${best.name}  score=${best.score.toFixed(3)}  thr=${best.thr}`));
+  else await safeCall(()=>ctx.reply("æ— æ¨¡æ¿"));
+});
+
+// Allow / Block
+bot.command("allow", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const id = Number((ctx.message as any).text.split(/\\s+/)[1]); if (!id) return void safeCall(()=>ctx.reply("ç”¨æ³•ï¼š/allow <userId>"));
+  allowlistSet.add(id); await store.addAllow(id); await safeCall(()=>ctx.reply(`âœ… å·²åŠ å…¥ç™½åå•ï¼š${id}`));
+});
+bot.command("unallow", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const id = Number((ctx.message as any).text.split(/\\s+/)[1]); if (!id) return void safeCall(()=>ctx.reply("ç”¨æ³•ï¼š/unallow <userId>"));
+  allowlistSet.delete(id); await store.removeAllow(id); await safeCall(()=>ctx.reply(`âœ… å·²ç§»å‡ºç™½åå•ï¼š${id}`));
+});
+bot.command("block", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const id = Number((ctx.message as any).text.split(/\\s+/)[1]); if (!id) return void safeCall(()=>ctx.reply("ç”¨æ³•ï¼š/block <userId>"));
+  blocklistSet.add(id); await store.addBlock(id); await safeCall(()=>ctx.reply(`â›” å·²å°ç¦ï¼š${id}`));
+});
+bot.command("unblock", async (ctx)=>{
+  if (!requireAdmin(ctx)) return;
+  const id = Number((ctx.message as any).text.split(/\\s+/)[1]); if (!id) return void safeCall(()=>ctx.reply("ç”¨æ³•ï¼š/unblock <userId>"));
+  blocklistSet.delete(id); await store.removeBlock(id); await safeCall(()=>ctx.reply(`âœ… å·²è§£å°ï¼š${id}`));
+});
+
+/** ====== Forward ====== */
+async function forwardToTarget(ctx: Context, sourceChatId: number|string, messageId: number, fromId: number, approvedBy: number, suspected?: Suspected) {
+  await safeCall(()=>ctx.telegram.forwardMessage(Number(cfg.forwardTargetId), Number(sourceChatId), Number(messageId)));
+  if (cfg.attachButtonsToTargetMeta) {
+    const kb = buildTrafficKeyboard();
+    const meta = `ğŸ“¨ æ¥è‡ªç”¨æˆ·ID:${fromId}ï¼Œå·²ç”±ç®¡ç†å‘˜ID:${approvedBy} å®¡æ ¸é€šè¿‡` + (suspected ? `\\nâš ï¸ æ¨¡æ¿å‘½ä¸­ï¼š${suspected.template}ï¼ˆscore=${suspected.score})` : "");
+    if (kb) await safeCall(()=>ctx.telegram.sendMessage(Number(cfg.forwardTargetId), meta, kb));
+    else await safeCall(()=>ctx.telegram.sendMessage(Number(cfg.forwardTargetId), meta));
+  }
+}
+
+/** ====== Startup ====== */
+(async () => {
+  await loadAll();
+  const WEBHOOK_URL = process.env.WEBHOOK_URL || "";
+  const PORT = Number(process.env.PORT || 3000);
+
+  if (WEBHOOK_URL) {
+    const path = "/webhook";
+    bot.telegram.setWebhook(`${WEBHOOK_URL}${path}`).then(()=>{
+      app.use(bot.webhookCallback(path));
+      console.log(`âœ… Webhook set: ${WEBHOOK_URL}${path}`);
+    }).catch((e)=>{
+      console.error("è®¾ç½® Webhook å¤±è´¥ï¼Œå›é€€åˆ°è½®è¯¢ï¼š", e);
+      bot.launch().then(()=>console.log("âœ… Bot started (polling)"));
+    });
+  } else {
+    bot.launch().then(()=>console.log("âœ… Bot started (polling)"));
+  }
+  app.listen(PORT, "0.0.0.0", ()=>console.log(`ğŸŒ Listening on ${PORT} (/healthz)`));
+  process.once("SIGINT", ()=>bot.stop("SIGINT"));
+  process.once("SIGTERM", ()=>bot.stop("SIGTERM"));
+})();
